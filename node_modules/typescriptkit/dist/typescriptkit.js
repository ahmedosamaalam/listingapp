(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./Extensions/ObjectExtensions.ts ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper Utility for objects and instances
     */
    var ObjectExtensions = (function () {
        function ObjectExtensions() {
        }
        /**
         * Check whether an object is null or undefined
         * @param object The object to check.
         */
        ObjectExtensions.isNullOrUndefined = function (object) {
            if (!!!object)
                return true; // This doesn't always work
            if (object === null)
                return true;
            if (object === undefined)
                return true;
            return false;
        };
        /**
         * Get all methods attached to an object
         * @param object The object to check.
         */
        ObjectExtensions.getAllMethods = function (object) {
            if (this.isNullOrUndefined(object))
                throw new ReferenceError('Cannot get methods from an undefined object');
            // Credit where credit is due: http://stackoverflow.com/a/35033472/2319865
            var props = [];
            do {
                var l = Object.getOwnPropertyNames(object)
                    .concat(Object.getOwnPropertySymbols(object).map(function (s) { return s.toString(); }))
                    .sort()
                    .filter(function (p, i, arr) {
                    return typeof object[p] === 'function' &&
                        p !== 'constructor' &&
                        (i === 0 || p !== arr[i - 1]) &&
                        props.indexOf(p) === -1;
                } // Not overridden in a child
                );
                props = props.concat(l);
                object = Object.getPrototypeOf(object); // Walk-up the prototype chain
            } while (!ObjectExtensions.isNullOrUndefined(object) &&
                // Not the the Object prototype methods (hasOwnProperty, etc...)
                !ObjectExtensions.isNullOrUndefined(Object.getPrototypeOf(object)));
            return props;
        };
        /**
         * Get the propertyDecorator for this object
         * @param object The object to check.
         * @param propertyName The name of the property the decorator is attached to.
         * @param descriptorName The name of the descript value where the decorator is attached to.
         */
        ObjectExtensions.getPropertyDecorator = function (object, propertyName, descriptorName) {
            if (!object.hasOwnProperty(propertyName))
                return null;
            var descriptor = Object.getOwnPropertyDescriptor(object, propertyName);
            if (ObjectExtensions.isNullOrUndefined(descriptor) ||
                ObjectExtensions.isNullOrUndefined(descriptor.value))
                return null;
            return descriptor.value[descriptorName];
        };
        return ObjectExtensions;
    }());
    exports.ObjectExtensions = ObjectExtensions;
    exports.default = ObjectExtensions;
    // tslint:disable-next-line:no-unused-expression
    /** Apply extensions to the Object interface */
    !function applyObjectExtensions() {
        var _this = this;
        Object.prototype['isNullOrUndefined'] = function () { return ObjectExtensions.isNullOrUndefined(_this); };
        Object.prototype['getAllMethods'] = function () { return ObjectExtensions.getAllMethods(_this); };
        Object.prototype['getPropertyDecorator'] = function (propertyName, descriptorName) {
            return ObjectExtensions.getPropertyDecorator(_this, propertyName, descriptorName);
        };
    }();
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!****************************************!*\
  !*** ./Extensions/StringExtensions.ts ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./ObjectExtensions */ 0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, ObjectExtensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper Utility for the String class
     */
    var StringExtensions = (function () {
        function StringExtensions() {
        }
        /**
         * Check whether a function is null or empty
         * @param stringObject The string to check.
         */
        StringExtensions.isNullOrEmpty = function (stringObject) {
            if (ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(stringObject))
                return true;
            if (stringObject === String())
                return true;
            return false;
        };
        /**
         * Check whether a function is null or consists of whitespace
         * @param stringObject The string to check.
         */
        StringExtensions.isNullOrWhitespace = function (stringObject) {
            if (ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(stringObject))
                return true;
            return StringExtensions.isNullOrEmpty(stringObject
                .toString() // <- Failsafe incase it's not a string
                .trim());
        };
        /**
         * Check whether a string starts with a certain character
         * @param stringObject The string to check.
         * @param startChar The character to check.
         */
        StringExtensions.startsWith = function (stringObject, startChar) {
            if (StringExtensions.isNullOrWhitespace(stringObject))
                return false;
            return stringObject[0] === startChar;
        };
        /**
         * Check whether a string ends with a certain character
         * @param stringObject The string to check.
         * @param character The character to check.
         */
        StringExtensions.endsWith = function (stringObject, character) {
            if (StringExtensions.isNullOrWhitespace(stringObject))
                return false;
            return stringObject[stringObject.length - 1] === character;
        };
        /**
         * Trim the given character at the start of the string
         * @param stringObject The string to trim.
         * @param character The character to trim.
         */
        StringExtensions.trimStartCharacters = function (stringObject, character) {
            if (StringExtensions.isNullOrWhitespace(stringObject))
                throw new ReferenceError("The parameter stringObject is required");
            if (StringExtensions.isNullOrWhitespace(character))
                character = ' ';
            return stringObject
                .replace(new RegExp("^" + character + "*", 'gmi'), String());
        };
        /**
         * Trim the given character at the end of the string
         * @param stringObject The string to trim.
         * @param character The character to trim.
         */
        StringExtensions.trimEndCharacters = function (stringObject, character) {
            if (StringExtensions.isNullOrWhitespace(stringObject))
                throw new ReferenceError("The parameter stringObject is required");
            if (StringExtensions.isNullOrWhitespace(character))
                character = ' ';
            return stringObject
                .replace(new RegExp(character + "*$", 'gmi'), String());
        };
        /**
         * Trim the given character at the start and end of the string
         * @param stringObject The string to trim.
         * @param character The character to trim.
         */
        StringExtensions.trimCharacters = function (stringObject, character) {
            if (StringExtensions.isNullOrWhitespace(stringObject))
                throw new ReferenceError("The parameter stringObject is required");
            if (StringExtensions.isNullOrWhitespace(character))
                return stringObject.trim();
            stringObject = StringExtensions.trimStartCharacters(stringObject, character);
            stringObject = StringExtensions.trimEndCharacters(stringObject, character);
            return stringObject;
        };
        return StringExtensions;
    }());
    exports.StringExtensions = StringExtensions;
    exports.default = StringExtensions;
    // tslint:disable-next-line:no-unused-expression
    /** Apply extensions to the String interface */
    !function applyStringExtensions() {
        var _this = this;
        Object.prototype['isNullOrEmpty'] = function () { return StringExtensions.isNullOrEmpty(_this); };
        Object.prototype['isNullOrWhitespace'] = function () { return StringExtensions.isNullOrWhitespace(_this); };
        Object.prototype['startsWith'] = function (startChar) {
            return StringExtensions.startsWith(_this, startChar);
        };
        Object.prototype['endsWith'] = function (character) {
            return StringExtensions.endsWith(_this, character);
        };
        Object.prototype['trimStartCharacters'] = function (character) {
            return StringExtensions.trimStartCharacters(_this, character);
        };
        Object.prototype['trimEndCharacters'] = function (character) {
            return StringExtensions.trimEndCharacters(_this, character);
        };
        Object.prototype['trimCharacters'] = function (character) {
            return StringExtensions.trimCharacters(_this, character);
        };
    }();
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!***************************************!*\
  !*** ./Decorators/SealedDecorator.ts ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Seal the class from inheritance
     */
    function sealed(constructor) {
        Object.seal(constructor);
        Object.seal(constructor.prototype);
        return constructor;
    }
    exports.sealed = sealed;
    exports.default = sealed;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!*************************************!*\
  !*** ./Helpers/SystemTypeHelper.ts ***!
  \*************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ../Extensions/ObjectExtensions */ 0)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, ObjectExtensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Helper Utility for system types
     */
    var SystemTypeHelper = (function () {
        function SystemTypeHelper() {
        }
        /**
         * Check whether an object is an array
         * @param object The object to check whether it it's an array
         */
        SystemTypeHelper.isArray = function (object) {
            if (object instanceof Array)
                return true;
            if (!ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(object.constructor))
                return object.constructor === Array;
            if (!ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(Array.isArray))
                return Array.isArray(object);
            return this.systemToString.call(object) === this.systemToString.call([]);
        };
        /**
         * Check whether an object is an object
         * @param object The object to check whether it it's an object
         */
        SystemTypeHelper.isObject = function (object) {
            if (object instanceof Object)
                return true;
            if (!ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(object.constructor))
                return object.constructor === Object;
            if (typeof (object) !== typeof ({}))
                return false;
            return this.systemToString.call(object) === this.systemToString.call({});
        };
        /**
         * Check whether an object is a string
         * @param object The object to check whether it it's an object
         */
        SystemTypeHelper.isString = function (object) {
            if (object instanceof String)
                return true;
            if (!ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(object.constructor))
                return object.constructor === String;
            return typeof (object) === typeof (String());
        };
        /**
         * Check whether an object is a function
         * @param object The object to check whether it it's a function
         */
        SystemTypeHelper.isFunction = function (object) {
            return typeof (object) === typeof (this.isFunction);
        };
        /**
         * Check whether an object is a numeric value
         * @param object The object to check whether it it's a number
         */
        SystemTypeHelper.isNumber = function (object) {
            return typeof (object) === typeof (0);
        };
        /**
         * Check whether an object is a boolean value
         * @param object The object to check whether it it's a boolean
         */
        SystemTypeHelper.isBoolean = function (object) {
            return typeof (object) === typeof (true);
        };
        return SystemTypeHelper;
    }());
    /**
     * Convert to string like intended regardless prototypal overrides.
     */
    SystemTypeHelper.systemToString = Object.prototype.toString;
    exports.SystemTypeHelper = SystemTypeHelper;
    exports.default = SystemTypeHelper;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!**********************************!*\
  !*** ./HttpClient/HttpClient.ts ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ../Extensions/ObjectExtensions */ 0), __webpack_require__(/*! ../Extensions/StringExtensions */ 1)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, ObjectExtensions_1, StringExtensions_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** Implementation of the xmlHttpclient implementing async promises */
    var HttpClient = (function () {
        function HttpClient(url) {
            var _this = this;
            this.httpHeaders = new Array();
            this.httpGet = function (path, success, error) {
                // ReSharper disable once InconsistentNaming (dafuq resharper?)
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.onreadystatechange = function () {
                    if (xmlHttp.readyState !== 4)
                        return;
                    if (xmlHttp.status === 200) {
                        success(xmlHttp.responseText);
                    }
                    else {
                        error(xmlHttp.responseText, xmlHttp.status);
                    }
                };
                xmlHttp.open("GET", _this.url, true); // true for asynchronous
                _this.applyRequestHeaders(xmlHttp);
                xmlHttp.send(null);
            };
            if (StringExtensions_1.StringExtensions.isNullOrWhitespace(url))
                throw new ReferenceError('The url needs to be defined');
            this.url = url;
        }
        /**
         * Set a value for the HttpHeaders for every request
         * @param key name of the header
         * @param value value of the header
         */
        HttpClient.prototype.setHttpHeader = function (key, value) {
            this.httpHeaders[key] = value;
            return this;
        };
        /**
         * Send a HttpGet request to an endpoint
         * @param path Uri extra path parameter
         */
        HttpClient.prototype.httpGetAsync = function (path) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                return _this.httpGet(_this.constructUrl(path), function (responseText) { return resolve(JSON.parse(responseText)); }, function (responseText, statusCode) { return reject(statusCode + ": " + responseText); });
            });
        };
        HttpClient.prototype.constructUrl = function (path) {
            if (StringExtensions_1.StringExtensions.isNullOrWhitespace(path))
                return this.url;
            return StringExtensions_1.StringExtensions.trimEndCharacters(this.url, '/') +
                ("/" + StringExtensions_1.StringExtensions.trimStartCharacters(path, '/'));
        };
        HttpClient.prototype.applyRequestHeaders = function (xmlHttp) {
            if (ObjectExtensions_1.ObjectExtensions.isNullOrUndefined(this.httpHeaders))
                return;
            var headers = this.httpHeaders;
            for (var headerKey in headers) {
                if (!headers.hasOwnProperty(headerKey))
                    continue;
                var headerValue = headers[headerKey];
                xmlHttp.setRequestHeader(headerKey, headerValue);
            }
        };
        return HttpClient;
    }());
    exports.HttpClient = HttpClient;
    exports.default = HttpClient;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 5 */
/* no static exports found */
/* all exports used */
/*!**************************!*\
  !*** ./TypeScriptKit.ts ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports, __webpack_require__(/*! ./Extensions/ObjectExtensions */ 0), __webpack_require__(/*! ./Extensions/StringExtensions */ 1), __webpack_require__(/*! ./Decorators/SealedDecorator */ 2), __webpack_require__(/*! ./Helpers/SystemTypeHelper */ 3), __webpack_require__(/*! ./HttpClient/HttpClient */ 4)], __WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, ObjectExtensions_1, StringExtensions_1, SealedDecorator_1, SystemTypeHelper_1, HttpClient_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectExtensions = ObjectExtensions_1.ObjectExtensions;
    exports.StringExtensions = StringExtensions_1.StringExtensions;
    exports.sealed = SealedDecorator_1.sealed;
    exports.SystemTypeHelper = SystemTypeHelper_1.SystemTypeHelper;
    exports.HttpClient = HttpClient_1.HttpClient;
    exports.default = ObjectExtensions_1.ObjectExtensions;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNjcmlwdGtpdC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIGU0MjY0ZTg3MDkwODhjN2M2ZmZjIiwid2VicGFjazovLy8uL0V4dGVuc2lvbnMvT2JqZWN0RXh0ZW5zaW9ucy50cyIsIndlYnBhY2s6Ly8vLi9FeHRlbnNpb25zL1N0cmluZ0V4dGVuc2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vRGVjb3JhdG9ycy9TZWFsZWREZWNvcmF0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vSGVscGVycy9TeXN0ZW1UeXBlSGVscGVyLnRzIiwid2VicGFjazovLy8uL0h0dHBDbGllbnQvSHR0cENsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9UeXBlU2NyaXB0S2l0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSBmYWN0b3J5KCk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlNDI2NGU4NzA5MDg4YzdjNmZmYyIsImRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgVXRpbGl0eSBmb3Igb2JqZWN0cyBhbmQgaW5zdGFuY2VzXHJcbiAgICAgKi9cclxuICAgIHZhciBPYmplY3RFeHRlbnNpb25zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBPYmplY3RFeHRlbnNpb25zKCkge1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBudWxsIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBPYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoISEhb2JqZWN0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIFRoaXMgZG9lc24ndCBhbHdheXMgd29ya1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgYWxsIG1ldGhvZHMgYXR0YWNoZWQgdG8gYW4gb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdEV4dGVuc2lvbnMuZ2V0QWxsTWV0aG9kcyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignQ2Fubm90IGdldCBtZXRob2RzIGZyb20gYW4gdW5kZWZpbmVkIG9iamVjdCcpO1xyXG4gICAgICAgICAgICAvLyBDcmVkaXQgd2hlcmUgY3JlZGl0IGlzIGR1ZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzUwMzM0NzIvMjMxOTg2NVxyXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBbXTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnRvU3RyaW5nKCk7IH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KClcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwLCBpLCBhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9iamVjdFtwXSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwICE9PSAnY29uc3RydWN0b3InICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpID09PSAwIHx8IHAgIT09IGFycltpIC0gMV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmluZGV4T2YocCkgPT09IC0xO1xyXG4gICAgICAgICAgICAgICAgfSAvLyBOb3Qgb3ZlcnJpZGRlbiBpbiBhIGNoaWxkXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBwcm9wcy5jb25jYXQobCk7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgLy8gV2Fsay11cCB0aGUgcHJvdG90eXBlIGNoYWluXHJcbiAgICAgICAgICAgIH0gd2hpbGUgKCFPYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKG9iamVjdCkgJiZcclxuICAgICAgICAgICAgICAgIC8vIE5vdCB0aGUgdGhlIE9iamVjdCBwcm90b3R5cGUgbWV0aG9kcyAoaGFzT3duUHJvcGVydHksIGV0Yy4uLilcclxuICAgICAgICAgICAgICAgICFPYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCB0aGUgcHJvcGVydHlEZWNvcmF0b3IgZm9yIHRoaXMgb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRoZSBkZWNvcmF0b3IgaXMgYXR0YWNoZWQgdG8uXHJcbiAgICAgICAgICogQHBhcmFtIGRlc2NyaXB0b3JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZXNjcmlwdCB2YWx1ZSB3aGVyZSB0aGUgZGVjb3JhdG9yIGlzIGF0dGFjaGVkIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE9iamVjdEV4dGVuc2lvbnMuZ2V0UHJvcGVydHlEZWNvcmF0b3IgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3JOYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghb2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgaWYgKE9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQoZGVzY3JpcHRvcikgfHxcclxuICAgICAgICAgICAgICAgIE9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQoZGVzY3JpcHRvci52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWVbZGVzY3JpcHRvck5hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdEV4dGVuc2lvbnM7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5PYmplY3RFeHRlbnNpb25zID0gT2JqZWN0RXh0ZW5zaW9ucztcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IE9iamVjdEV4dGVuc2lvbnM7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cclxuICAgIC8qKiBBcHBseSBleHRlbnNpb25zIHRvIHRoZSBPYmplY3QgaW50ZXJmYWNlICovXHJcbiAgICAhZnVuY3Rpb24gYXBwbHlPYmplY3RFeHRlbnNpb25zKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZVsnaXNOdWxsT3JVbmRlZmluZWQnXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQoX3RoaXMpOyB9O1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGVbJ2dldEFsbE1ldGhvZHMnXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE9iamVjdEV4dGVuc2lvbnMuZ2V0QWxsTWV0aG9kcyhfdGhpcyk7IH07XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZVsnZ2V0UHJvcGVydHlEZWNvcmF0b3InXSA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3JOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3RFeHRlbnNpb25zLmdldFByb3BlcnR5RGVjb3JhdG9yKF90aGlzLCBwcm9wZXJ0eU5hbWUsIGRlc2NyaXB0b3JOYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9FeHRlbnNpb25zL09iamVjdEV4dGVuc2lvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9PYmplY3RFeHRlbnNpb25zXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgT2JqZWN0RXh0ZW5zaW9uc18xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIFV0aWxpdHkgZm9yIHRoZSBTdHJpbmcgY2xhc3NcclxuICAgICAqL1xyXG4gICAgdmFyIFN0cmluZ0V4dGVuc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFN0cmluZ0V4dGVuc2lvbnMoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgYSBmdW5jdGlvbiBpcyBudWxsIG9yIGVtcHR5XHJcbiAgICAgICAgICogQHBhcmFtIHN0cmluZ09iamVjdCBUaGUgc3RyaW5nIHRvIGNoZWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmluZ0V4dGVuc2lvbnMuaXNOdWxsT3JFbXB0eSA9IGZ1bmN0aW9uIChzdHJpbmdPYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdEV4dGVuc2lvbnNfMS5PYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKHN0cmluZ09iamVjdCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHN0cmluZ09iamVjdCA9PT0gU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciBhIGZ1bmN0aW9uIGlzIG51bGwgb3IgY29uc2lzdHMgb2Ygd2hpdGVzcGFjZVxyXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdPYmplY3QgVGhlIHN0cmluZyB0byBjaGVjay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIChzdHJpbmdPYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdEV4dGVuc2lvbnNfMS5PYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKHN0cmluZ09iamVjdCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0V4dGVuc2lvbnMuaXNOdWxsT3JFbXB0eShzdHJpbmdPYmplY3RcclxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpIC8vIDwtIEZhaWxzYWZlIGluY2FzZSBpdCdzIG5vdCBhIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgLnRyaW0oKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIHN0YXJ0cyB3aXRoIGEgY2VydGFpbiBjaGFyYWN0ZXJcclxuICAgICAgICAgKiBAcGFyYW0gc3RyaW5nT2JqZWN0IFRoZSBzdHJpbmcgdG8gY2hlY2suXHJcbiAgICAgICAgICogQHBhcmFtIHN0YXJ0Q2hhciBUaGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmluZ0V4dGVuc2lvbnMuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHJpbmdPYmplY3QsIHN0YXJ0Q2hhcikge1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nRXh0ZW5zaW9ucy5pc051bGxPcldoaXRlc3BhY2Uoc3RyaW5nT2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ09iamVjdFswXSA9PT0gc3RhcnRDaGFyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciBhIHN0cmluZyBlbmRzIHdpdGggYSBjZXJ0YWluIGNoYXJhY3RlclxyXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdPYmplY3QgVGhlIHN0cmluZyB0byBjaGVjay5cclxuICAgICAgICAgKiBAcGFyYW0gY2hhcmFjdGVyIFRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3RyaW5nRXh0ZW5zaW9ucy5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzdHJpbmdPYmplY3QsIGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nRXh0ZW5zaW9ucy5pc051bGxPcldoaXRlc3BhY2Uoc3RyaW5nT2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ09iamVjdFtzdHJpbmdPYmplY3QubGVuZ3RoIC0gMV0gPT09IGNoYXJhY3RlcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGdpdmVuIGNoYXJhY3RlciBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdPYmplY3QgVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAgICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIGNoYXJhY3RlciB0byB0cmltLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmluZ0V4dGVuc2lvbnMudHJpbVN0YXJ0Q2hhcmFjdGVycyA9IGZ1bmN0aW9uIChzdHJpbmdPYmplY3QsIGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nRXh0ZW5zaW9ucy5pc051bGxPcldoaXRlc3BhY2Uoc3RyaW5nT2JqZWN0KSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIlRoZSBwYXJhbWV0ZXIgc3RyaW5nT2JqZWN0IGlzIHJlcXVpcmVkXCIpO1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nRXh0ZW5zaW9ucy5pc051bGxPcldoaXRlc3BhY2UoY2hhcmFjdGVyKSlcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlciA9ICcgJztcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ09iamVjdFxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChcIl5cIiArIGNoYXJhY3RlciArIFwiKlwiLCAnZ21pJyksIFN0cmluZygpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaW0gdGhlIGdpdmVuIGNoYXJhY3RlciBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmdcclxuICAgICAgICAgKiBAcGFyYW0gc3RyaW5nT2JqZWN0IFRoZSBzdHJpbmcgdG8gdHJpbS5cclxuICAgICAgICAgKiBAcGFyYW0gY2hhcmFjdGVyIFRoZSBjaGFyYWN0ZXIgdG8gdHJpbS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTdHJpbmdFeHRlbnNpb25zLnRyaW1FbmRDaGFyYWN0ZXJzID0gZnVuY3Rpb24gKHN0cmluZ09iamVjdCwgY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yV2hpdGVzcGFjZShzdHJpbmdPYmplY3QpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiVGhlIHBhcmFtZXRlciBzdHJpbmdPYmplY3QgaXMgcmVxdWlyZWRcIik7XHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yV2hpdGVzcGFjZShjaGFyYWN0ZXIpKVxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gJyAnO1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nT2JqZWN0XHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKGNoYXJhY3RlciArIFwiKiRcIiwgJ2dtaScpLCBTdHJpbmcoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmltIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIHN0cmluZ1xyXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdPYmplY3QgVGhlIHN0cmluZyB0byB0cmltLlxyXG4gICAgICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIGNoYXJhY3RlciB0byB0cmltLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN0cmluZ0V4dGVuc2lvbnMudHJpbUNoYXJhY3RlcnMgPSBmdW5jdGlvbiAoc3RyaW5nT2JqZWN0LCBjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0V4dGVuc2lvbnMuaXNOdWxsT3JXaGl0ZXNwYWNlKHN0cmluZ09iamVjdCkpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJUaGUgcGFyYW1ldGVyIHN0cmluZ09iamVjdCBpcyByZXF1aXJlZFwiKTtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0V4dGVuc2lvbnMuaXNOdWxsT3JXaGl0ZXNwYWNlKGNoYXJhY3RlcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nT2JqZWN0LnRyaW0oKTtcclxuICAgICAgICAgICAgc3RyaW5nT2JqZWN0ID0gU3RyaW5nRXh0ZW5zaW9ucy50cmltU3RhcnRDaGFyYWN0ZXJzKHN0cmluZ09iamVjdCwgY2hhcmFjdGVyKTtcclxuICAgICAgICAgICAgc3RyaW5nT2JqZWN0ID0gU3RyaW5nRXh0ZW5zaW9ucy50cmltRW5kQ2hhcmFjdGVycyhzdHJpbmdPYmplY3QsIGNoYXJhY3Rlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdPYmplY3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3RyaW5nRXh0ZW5zaW9ucztcclxuICAgIH0oKSk7XHJcbiAgICBleHBvcnRzLlN0cmluZ0V4dGVuc2lvbnMgPSBTdHJpbmdFeHRlbnNpb25zO1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gU3RyaW5nRXh0ZW5zaW9ucztcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby11bnVzZWQtZXhwcmVzc2lvblxyXG4gICAgLyoqIEFwcGx5IGV4dGVuc2lvbnMgdG8gdGhlIFN0cmluZyBpbnRlcmZhY2UgKi9cclxuICAgICFmdW5jdGlvbiBhcHBseVN0cmluZ0V4dGVuc2lvbnMoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBPYmplY3QucHJvdG90eXBlWydpc051bGxPckVtcHR5J10gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yRW1wdHkoX3RoaXMpOyB9O1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGVbJ2lzTnVsbE9yV2hpdGVzcGFjZSddID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU3RyaW5nRXh0ZW5zaW9ucy5pc051bGxPcldoaXRlc3BhY2UoX3RoaXMpOyB9O1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGVbJ3N0YXJ0c1dpdGgnXSA9IGZ1bmN0aW9uIChzdGFydENoYXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0V4dGVuc2lvbnMuc3RhcnRzV2l0aChfdGhpcywgc3RhcnRDaGFyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGVbJ2VuZHNXaXRoJ10gPSBmdW5jdGlvbiAoY2hhcmFjdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdFeHRlbnNpb25zLmVuZHNXaXRoKF90aGlzLCBjaGFyYWN0ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZVsndHJpbVN0YXJ0Q2hhcmFjdGVycyddID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRXh0ZW5zaW9ucy50cmltU3RhcnRDaGFyYWN0ZXJzKF90aGlzLCBjaGFyYWN0ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZVsndHJpbUVuZENoYXJhY3RlcnMnXSA9IGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0V4dGVuc2lvbnMudHJpbUVuZENoYXJhY3RlcnMoX3RoaXMsIGNoYXJhY3Rlcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBPYmplY3QucHJvdG90eXBlWyd0cmltQ2hhcmFjdGVycyddID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nRXh0ZW5zaW9ucy50cmltQ2hhcmFjdGVycyhfdGhpcywgY2hhcmFjdGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpO1xyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9FeHRlbnNpb25zL1N0cmluZ0V4dGVuc2lvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFNlYWwgdGhlIGNsYXNzIGZyb20gaW5oZXJpdGFuY2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2VhbGVkKGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgT2JqZWN0LnNlYWwoY29uc3RydWN0b3IpO1xyXG4gICAgICAgIE9iamVjdC5zZWFsKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xyXG4gICAgfVxyXG4gICAgZXhwb3J0cy5zZWFsZWQgPSBzZWFsZWQ7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBzZWFsZWQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0RlY29yYXRvcnMvU2VhbGVkRGVjb3JhdG9yLnRzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL0V4dGVuc2lvbnMvT2JqZWN0RXh0ZW5zaW9uc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIE9iamVjdEV4dGVuc2lvbnNfMSkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBVdGlsaXR5IGZvciBzeXN0ZW0gdHlwZXNcclxuICAgICAqL1xyXG4gICAgdmFyIFN5c3RlbVR5cGVIZWxwZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIFN5c3RlbVR5cGVIZWxwZXIoKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGFuIGFycmF5XHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQgaXQncyBhbiBhcnJheVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFN5c3RlbVR5cGVIZWxwZXIuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0RXh0ZW5zaW9uc18xLk9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0LmNvbnN0cnVjdG9yKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IgPT09IEFycmF5O1xyXG4gICAgICAgICAgICBpZiAoIU9iamVjdEV4dGVuc2lvbnNfMS5PYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKEFycmF5LmlzQXJyYXkpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqZWN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3lzdGVtVG9TdHJpbmcuY2FsbChvYmplY3QpID09PSB0aGlzLnN5c3RlbVRvU3RyaW5nLmNhbGwoW10pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaXMgYW4gb2JqZWN0XHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQgaXQncyBhbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBTeXN0ZW1UeXBlSGVscGVyLmlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgT2JqZWN0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0RXh0ZW5zaW9uc18xLk9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0LmNvbnN0cnVjdG9yKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IgPT09IE9iamVjdDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAob2JqZWN0KSAhPT0gdHlwZW9mICh7fSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN5c3RlbVRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gdGhpcy5zeXN0ZW1Ub1N0cmluZy5jYWxsKHt9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgc3RyaW5nXHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQgaXQncyBhbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBTeXN0ZW1UeXBlSGVscGVyLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGlmICghT2JqZWN0RXh0ZW5zaW9uc18xLk9iamVjdEV4dGVuc2lvbnMuaXNOdWxsT3JVbmRlZmluZWQob2JqZWN0LmNvbnN0cnVjdG9yKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IgPT09IFN0cmluZztcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAob2JqZWN0KSA9PT0gdHlwZW9mIChTdHJpbmcoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQgaXQncyBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3lzdGVtVHlwZUhlbHBlci5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKG9iamVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIChvYmplY3QpID09PSB0eXBlb2YgKHRoaXMuaXNGdW5jdGlvbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBpcyBhIG51bWVyaWMgdmFsdWVcclxuICAgICAgICAgKiBAcGFyYW0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2sgd2hldGhlciBpdCBpdCdzIGEgbnVtYmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3lzdGVtVHlwZUhlbHBlci5pc051bWJlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiAob2JqZWN0KSA9PT0gdHlwZW9mICgwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgYm9vbGVhbiB2YWx1ZVxyXG4gICAgICAgICAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0IGl0J3MgYSBib29sZWFuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU3lzdGVtVHlwZUhlbHBlci5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgKG9iamVjdCkgPT09IHR5cGVvZiAodHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU3lzdGVtVHlwZUhlbHBlcjtcclxuICAgIH0oKSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgdG8gc3RyaW5nIGxpa2UgaW50ZW5kZWQgcmVnYXJkbGVzcyBwcm90b3R5cGFsIG92ZXJyaWRlcy5cclxuICAgICAqL1xyXG4gICAgU3lzdGVtVHlwZUhlbHBlci5zeXN0ZW1Ub1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XHJcbiAgICBleHBvcnRzLlN5c3RlbVR5cGVIZWxwZXIgPSBTeXN0ZW1UeXBlSGVscGVyO1xyXG4gICAgZXhwb3J0cy5kZWZhdWx0ID0gU3lzdGVtVHlwZUhlbHBlcjtcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vSGVscGVycy9TeXN0ZW1UeXBlSGVscGVyLnRzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIi4uL0V4dGVuc2lvbnMvT2JqZWN0RXh0ZW5zaW9uc1wiLCBcIi4uL0V4dGVuc2lvbnMvU3RyaW5nRXh0ZW5zaW9uc1wiXSwgZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIE9iamVjdEV4dGVuc2lvbnNfMSwgU3RyaW5nRXh0ZW5zaW9uc18xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIC8qKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgeG1sSHR0cGNsaWVudCBpbXBsZW1lbnRpbmcgYXN5bmMgcHJvbWlzZXMgKi9cclxuICAgIHZhciBIdHRwQ2xpZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBIdHRwQ2xpZW50KHVybCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmh0dHBIZWFkZXJzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaHR0cEdldCA9IGZ1bmN0aW9uIChwYXRoLCBzdWNjZXNzLCBlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVTaGFycGVyIGRpc2FibGUgb25jZSBJbmNvbnNpc3RlbnROYW1pbmcgKGRhZnVxIHJlc2hhcnBlcj8pXHJcbiAgICAgICAgICAgICAgICB2YXIgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhtbEh0dHAucmVhZHlTdGF0ZSAhPT0gNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxIdHRwLnN0YXR1cyA9PT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MoeG1sSHR0cC5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoeG1sSHR0cC5yZXNwb25zZVRleHQsIHhtbEh0dHAuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgeG1sSHR0cC5vcGVuKFwiR0VUXCIsIF90aGlzLnVybCwgdHJ1ZSk7IC8vIHRydWUgZm9yIGFzeW5jaHJvbm91c1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwbHlSZXF1ZXN0SGVhZGVycyh4bWxIdHRwKTtcclxuICAgICAgICAgICAgICAgIHhtbEh0dHAuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0V4dGVuc2lvbnNfMS5TdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yV2hpdGVzcGFjZSh1cmwpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCdUaGUgdXJsIG5lZWRzIHRvIGJlIGRlZmluZWQnKTtcclxuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhIHZhbHVlIGZvciB0aGUgSHR0cEhlYWRlcnMgZm9yIGV2ZXJ5IHJlcXVlc3RcclxuICAgICAgICAgKiBAcGFyYW0ga2V5IG5hbWUgb2YgdGhlIGhlYWRlclxyXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSHR0cENsaWVudC5wcm90b3R5cGUuc2V0SHR0cEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaHR0cEhlYWRlcnNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbmQgYSBIdHRwR2V0IHJlcXVlc3QgdG8gYW4gZW5kcG9pbnRcclxuICAgICAgICAgKiBAcGFyYW0gcGF0aCBVcmkgZXh0cmEgcGF0aCBwYXJhbWV0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5odHRwR2V0QXN5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmh0dHBHZXQoX3RoaXMuY29uc3RydWN0VXJsKHBhdGgpLCBmdW5jdGlvbiAocmVzcG9uc2VUZXh0KSB7IHJldHVybiByZXNvbHZlKEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KSk7IH0sIGZ1bmN0aW9uIChyZXNwb25zZVRleHQsIHN0YXR1c0NvZGUpIHsgcmV0dXJuIHJlamVjdChzdGF0dXNDb2RlICsgXCI6IFwiICsgcmVzcG9uc2VUZXh0KTsgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSHR0cENsaWVudC5wcm90b3R5cGUuY29uc3RydWN0VXJsID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0V4dGVuc2lvbnNfMS5TdHJpbmdFeHRlbnNpb25zLmlzTnVsbE9yV2hpdGVzcGFjZShwYXRoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVybDtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0V4dGVuc2lvbnNfMS5TdHJpbmdFeHRlbnNpb25zLnRyaW1FbmRDaGFyYWN0ZXJzKHRoaXMudXJsLCAnLycpICtcclxuICAgICAgICAgICAgICAgIChcIi9cIiArIFN0cmluZ0V4dGVuc2lvbnNfMS5TdHJpbmdFeHRlbnNpb25zLnRyaW1TdGFydENoYXJhY3RlcnMocGF0aCwgJy8nKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBIdHRwQ2xpZW50LnByb3RvdHlwZS5hcHBseVJlcXVlc3RIZWFkZXJzID0gZnVuY3Rpb24gKHhtbEh0dHApIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdEV4dGVuc2lvbnNfMS5PYmplY3RFeHRlbnNpb25zLmlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuaHR0cEhlYWRlcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuaHR0cEhlYWRlcnM7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGhlYWRlcktleSBpbiBoZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyS2V5KSlcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJWYWx1ZSA9IGhlYWRlcnNbaGVhZGVyS2V5XTtcclxuICAgICAgICAgICAgICAgIHhtbEh0dHAuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJLZXksIGhlYWRlclZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEh0dHBDbGllbnQ7XHJcbiAgICB9KCkpO1xyXG4gICAgZXhwb3J0cy5IdHRwQ2xpZW50ID0gSHR0cENsaWVudDtcclxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IEh0dHBDbGllbnQ7XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL0h0dHBDbGllbnQvSHR0cENsaWVudC50c1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCIuL0V4dGVuc2lvbnMvT2JqZWN0RXh0ZW5zaW9uc1wiLCBcIi4vRXh0ZW5zaW9ucy9TdHJpbmdFeHRlbnNpb25zXCIsIFwiLi9EZWNvcmF0b3JzL1NlYWxlZERlY29yYXRvclwiLCBcIi4vSGVscGVycy9TeXN0ZW1UeXBlSGVscGVyXCIsIFwiLi9IdHRwQ2xpZW50L0h0dHBDbGllbnRcIl0sIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBPYmplY3RFeHRlbnNpb25zXzEsIFN0cmluZ0V4dGVuc2lvbnNfMSwgU2VhbGVkRGVjb3JhdG9yXzEsIFN5c3RlbVR5cGVIZWxwZXJfMSwgSHR0cENsaWVudF8xKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgIGV4cG9ydHMuT2JqZWN0RXh0ZW5zaW9ucyA9IE9iamVjdEV4dGVuc2lvbnNfMS5PYmplY3RFeHRlbnNpb25zO1xyXG4gICAgZXhwb3J0cy5TdHJpbmdFeHRlbnNpb25zID0gU3RyaW5nRXh0ZW5zaW9uc18xLlN0cmluZ0V4dGVuc2lvbnM7XHJcbiAgICBleHBvcnRzLnNlYWxlZCA9IFNlYWxlZERlY29yYXRvcl8xLnNlYWxlZDtcclxuICAgIGV4cG9ydHMuU3lzdGVtVHlwZUhlbHBlciA9IFN5c3RlbVR5cGVIZWxwZXJfMS5TeXN0ZW1UeXBlSGVscGVyO1xyXG4gICAgZXhwb3J0cy5IdHRwQ2xpZW50ID0gSHR0cENsaWVudF8xLkh0dHBDbGllbnQ7XHJcbiAgICBleHBvcnRzLmRlZmF1bHQgPSBPYmplY3RFeHRlbnNpb25zXzEuT2JqZWN0RXh0ZW5zaW9ucztcclxufSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vVHlwZVNjcmlwdEtpdC50c1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QTs7Ozs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOzs7Ozs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7Ozs7Ozs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7Ozs7O0EiLCJzb3VyY2VSb290IjoiIn0=